
Ara fem servir AIC_builder. Llavors la meva manera de construir l'AIC ja no cal? O SI?


% AIC matrix coefficients
AIC = zeros(N_panels,N_panels);
for i = 1:N_panels
    % Collocation point coordinates of panel "i"
    x_i = x_p(i,3);
    y_i = y_p(i,3);
    % Loop through all doublet segments
    for j = 1:N_panels
        y_mid_j = y_p(j,3);
        c_local = c_root * (1 - (1 - lambda) * (y_mid_j - y0)/b);
        % We add the induced velocity contribution to the AIC
        AIC(i,j) = AIC(i,j) + w_doublet(x_i,y_i,x_p(j,:),y_p(j,:),c_local/2,M_inf,k,1);
        AIC(i,j) = AIC(i,j) + w_doublet(x_i,y_i,x_p(j,[2,1,3]),-y_p(j,[2,1,3]),c_local/2,M_inf,k,1);
    end



PODEM DEFINIR h a un altre lloc?






%%%%%%%%%%%%%%%%%%%%%%%%%%%% COSES EXTRA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%% FIGURA NODES I ELEMENTS DE L'ALA %%%%%%%%%%%%%
%ficar-ho al modal analysis despres de la definicio de nodes i elements


figure; hold on; axis equal; grid on

% Elements
for e = 1:size(elem,1)
    xy = nodes(elem(e,:),:);
    plot([xy(:,1); xy(1,1)], [xy(:,2); xy(1,2)], 'k-');

    % número d’element (al centre)
    xc = mean(xy(:,1));
    yc = mean(xy(:,2));
    text(xc, yc, num2str(e), 'Color','r','FontSize',8,...
        'HorizontalAlignment','center');
end

% Nodes
plot(nodes(:,1), nodes(:,2), 'b.', 'MarkerSize', 12)

for k = 1:size(nodes,1)
    text(nodes(k,1), nodes(k,2), [' ' num2str(k)], ...
        'Color','b','FontSize',8);
end

xlabel('x'); ylabel('y');
title('Wing structural mesh (nodes + elements)');
%%%%%%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%%%%%% CLASSIFICACIÓ UD %%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compute divergence speed with ALL MODES
[X_div,U_2inf] = eigs(sparse(K(I_free,I_free)), sparse(A0(I_free,I_free)), 10, 'smallestabs');

lambda = diag(U_2inf);  %extra         % lambda = U^2
tol = 1e-8 * max(1, max(abs(lambda)));
valid = abs(imag(lambda)) < tol & real(lambda) > 0;
U_inf2 = sort(sqrt(real(lambda(valid))));

U_inf_ALEX = sort(diag(sqrt(U_2inf))) %CREC QUE SOLAPAVEM U_inf 
Ud_allmodes = U_inf2(1) %DIVERGENCE SPEED, assumint que el 1r eigenvalue es real


% Compute divergence speed with REDUCED SYSTEM (i_modes)

q_mod = zeros(N_dof,length(I_free));
[q_mod(I_free,:),w2] = eig(K_free,M_free);
freq = sqrt(diag(w2))/(2*pi); %frequencia 
K_red = q_mod(:,i_modes)'*K*q_mod(:,i_modes);
A0_red = q_mod(:,i_modes)'*A0*q_mod(:,i_modes);

[X_div,U_3inf] = eig(K_red,A0_red);

lambda2 = diag(U_3inf);  %extra         % lambda = U^2
tol = 1e-8 * max(1, max(abs(lambda2)));
valid = abs(imag(lambda2)) < tol & real(lambda2) > 0;
U_inf3 = sort(sqrt(real(lambda2(valid))));

%U_inf3 = sort(diag(sqrt(U_3inf)));

Ud_reduced = U_inf3(1) %DIVERGENCE SPEED, assumint que el 1r eigenvalue es real

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






























function plotSpanwiseProperties(span)
y = span.y(:);

figure('Name','Cross-section properties along the span','Color','w');

tiledlayout(3,3,'Padding','compact','TileSpacing','compact');

% 1) Chord distribution
nexttile;
plot(y, span.c_y, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('c(y) (m)');
title('Chord c(y)');

% 2) Bending stiffness EI
nexttile;
plot(y, span.EI, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('EI (N·m^2)');
title('Bending stiffness EI');

% 3) Torsional stiffness GJ
nexttile;
plot(y, span.GJ, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('GJ (N·m^2)');
title('Torsional stiffness GJ');

% 4) Mass per unit length m
nexttile;
plot(y, span.m, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('m (kg/m)');
title('Mass per unit length m');

% 5) Torsion reference inertia I_sc (structural)
nexttile;
plot(y, span.I_sc, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('I_{sc} (m^4)');
title('I_{sc} (torsion ref.)');

% 6) Mass polar inertia about torsion ref (rho*I_sc)
% (you store it as span.I_sc_mass)
nexttile;
plot(y, span.I_sc_mass, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('\rho I_{sc} (kg·m)');
title('Mass inertia per length (\rho I_{sc})');

% 7) x_cm and x_sc along span
nexttile;
plot(y, span.x_cm, 'LineWidth', 1.5); hold on;
plot(y, span.x_sc, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('x (m)');
title('x_{cm}(y) and x_{sc}(y)');
legend('x_{cm}','x_{sc}','Location','best');

% 8) d = x_cm - x_sc
nexttile;
plot(y, span.d, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('d (m)');
title('Offset d = x_{cm} - x_{sc}');

% 9) dx_sc shift you applied to align SC line
%nexttile;
%plot(y, span.dx_sc, 'LineWidth', 1.5);
%grid on; xlabel('y (m)'); ylabel('\Deltax_{sc} (m)');
%title('Applied shift \Deltax_{sc}(y)');

% 9) Check shear center line perpendicular to span (x_sc_global constant)
nexttile;
x_sc_global = span.x_sc + span.dx_sc;   % global x-position of shear center line
plot(y, x_sc_global, 'LineWidth', 1.5);
grid on; xlabel('y (m)'); ylabel('x_{sc}^{glob} (m)');
title('Shear center line check: x_{sc}^{glob}(y)');

sgtitle('Cross-section properties along the span');

end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%
%Check validity p method (k<<)
%tol_w = 1e-6;                         
%osc = abs(imag(p_(:,i))) > tol_w;
%if any(osc)
%    [~, jj] = max(real(p_(osc,i)));  % most unstable oscillatory root
%    idx = find(osc);
%    jcrit = idx(jj);
%    omega = abs(imag(p_(jcrit,i)));    % rad/s
%    k_validation(i) = omega * c_root / (2*U_(i)); %reduced frequency
%end

[~, jcrit] = max(real(p_(:,i)));%el eigenvalue amb part real major es el critic per flutter 
omega = abs(imag(p_(jcrit,i))); % rad/s %(pag 172) | imag(p) = w | 
k_validation(i) = omega * c_root / (2*U_(i));
%%%%%%%%%%%%%%%%%%%%%%


